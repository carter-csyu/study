# JAVA

## 목차(Table of Contents)

1. 변수(Variable)
2. 연산자(Operator)
3. 조건문과 반복문
4. 배열
5. 객체지향 프로그래밍 I
6. 객체지향 프로그래밍 II
7. 예외처리(Exception Handling)
8. java.lang Pakage
9. 내부 클래스
10. 컬랙션 프레임워크와 유용한 클래스
11. 쓰레드(Thread)
12. 입출력(I/O)
13. 네트워킹(Networking)

- - -

## 0. JAVA(Java Programming Language)

## 0.1. 자바언어의 특징

1. 운영체제에 독립적이다.
2. 객체지향언어이다.
3. 자동 메모리 관리(Garbage Collection)
4. 네트워크와 분산처리를 지원
5. 멀티쓰레드를 지원(Multi-thread)
6. 동적 로딩(Dynamic Loading) 지원

## 1. 변수(Variable)

## 1.1. 변수의 타입
- 기본형(Primitive type)
	`boolean`, `char`, `byte`, `short`, `int`, `long`, `float`, `double`
  계산을 위한 실제 값을 저장한다.

	| 종류/크기 | 1 byte | 2 byte | 4 byte | 8 byte |
  |--------|:--------:|:--------:|:--------:|:--------:|
  | 논리형 | `boolean` | | | |
  | 문자형 | | `char` | | |
  | 정수형 | `byte` | `short` | `int` | `long` |
  | 실수형 | | | `float` | `double` |


- 참조형(Reference type)
	8개의 기본형을 제외한 나머지 타입, 객체의 주소를 저장

## 1.2. 문자열 변환
```java
// 문자열 + any type -> 문자열 + 문자열 -> 문자열
// any type + answkduf -> 문자열 + 문자열 -> 문자열

String toStr = 7 + ""; // 7 (문자열 변환시 "" 사용)
```

## 1.3. 형변환
```java
// (타입) 피연산자, '캐스트 연산자' 또는 '형변환 연산자' 이용
int score = (int)85.1; // 85
```

> 1. `boolean`을 제외한 나머지 7개의 기본형은 서로 형변환이 가능하다.
> 2. 기본형과 참조형은 서로 형변환할 수 없다.
> 3. 서로 다른 타입의 변수간의 연산은 형변환을 하는 것이 원칙이지만,
값의 범위가 작은 타입에서 큰 타입으로의 형변환은 생략할 수 있다.

## 1.4. 변수의 타입에 따른 기본 값

| 자료형 | 기본값 |
| :---: | :---: |
| `boolean` | `false` |
| `char` | `\u0000` |
| `byte`, `short`, `int` | `0` |
| `long` | `0L` |
| `float` | `0.0f` |
| `double` | `0.0d` 또는 `0.0` |
| 참조형 변수 | `null` |


## 2. 연산자

1. (단항) > 산술 > 비교 > 논리 > (삼항) > 대입
2. 단항(1) > 이항(2) > 삼항(3). 단항 연산자의 우선순위가 이항 연산자보다 높다.
3. 단항 연산자와 대입 연산자를 제외한 모든 연산의 진행방향은 왼쪽에서 오른쪽이다. (←)

## 2.1. 피연산자의 타입에 따른 이항연산결과

| 피연산자1 | 피연산자2 | 연산결과 |
| ------ | :------: | :------: |
| `byte`, `short`, `char` | `byte`, `short`, `char` | `int` |
| `byte`, `short`, `char`, `int` | `int` | `int` |
| `byte`, `short`, `char`, `int`, `long` | `long` | `long` |
| `byte`, `short`, `char`, `int`, `long`, `float` | `float` | `float` |
| `byte`, `short`, `char`, `int`, `long`, `float`, `double` | `double` | `double` |

## 3. 조건문과 반복문

## 3.1. 조건문 - `if`, `switch`

The Syntax of `if`:
```java
if (조건식 1) {
	// '조건식 1'의 연산결과가 true일 때 수행될 문장
} else if (조건식 2) {
	// '조건식 2'의 연산결과가 true일 때 수행될 문장
} else {
	// 위의 어느 조건식도 만족하지 않을 때 수행될 문장
}
```

The Syntax of `switch`:
```java
switch (조건식) {
	case 값1:
  	// 조건식의 결과가 값1과 같을 경우 수행될 문장
  	break;
  case 값2:
  	// 조건식의 결과가 값2와 같을 경우 수행될 문장
    break;
  // ...
  default:
  	// 조건식의 결과와 일치하는 case문이 없을 때 수행될 문장
}
```

## 3.2. 반복문 - `for`, `while`, `do-while`

The syntax of `for`:
```java
// 실행 순서 (초기화 > 조건식 > 수행될 문장 > 증감식 > 조건식)
for (초기화; 조건식; 증감식) {
	// 조건식이 true일 때 수행될 문장
}
```

The syntax of `while`:
```java
while (조건식) {
	// 조건식의 연산결과가 true일 때 수행될 문장
}
```

The syntax of `do-while`:
```java
do {
	// 조건식의 연산결과가 true 일 때 수행될 문장(첫 진입시에는 조건식을 확인하지 않음)
} while (조건식);
```

## 3.3. break & continue
- `break` - 현재 위치에서 가장 가까운 `switch` 또는 반복문을 벗어나는데 사용
- `continue` - 반복문의 끝으로 이동하여 다음 반복을 진행하는데 사용

## 3.4. 반복문을 위한 라벨(Label for Loops)

반복문이 중첩되어 있는 경우 라벨을 사용하여 가장 가까운 위치의 반복문이 아닌
라벨이 선언된 위치로 이동할 수 있다.

```java
Loop1: for(int i=2; i <= 9; i++) {
  for(int j=1; j <= 9; j++) {
    if(j == 5) {
      // break Loop1; // (1)
      // break; // (2)
      // continue Loop1; // (3)
      // continue; // (4)
    }
    System.out.println(i + "*" + j + "=" + i*j);
    // (4)
  } // (2)
  // (3)
}
// (1)
```

## 4. 배열

## 4.1. 배열의 선언 및 생성
원하는 타입을 선언하고, 변수 또는 타입에 배열임을 의미하는 대괄호 `[]`를 붙인다.

| 선언방법 | 선언 예 |
| ------ | ------ |
| 타입[] 변수이름; | int[] score; |
| 타입 변수이름[]; | int score[]; |

```java
int[] score; // 배열을 선언한다. (생성된 배열을 다루는데 사용될 참조변수 선언)
score = new int[5] // 배열을 생성한다. (5개의 int값을 저장할 수 있는 공간 생성)
```

## 4.2. 배열의 초기화
```java
int[] score = { 100, 90, 80, 70 }; // (1)
int[] score = new int[]{ 100, 90, 80, 70 }; // (2)

String[] name = { new String("Kim"), new String("Park"), new String("Yu") }; // (2)
String[] name = { "Kim", "Park", "Yu" }; // (1)
String[] name = new String[]{ "Kim", "Park", "Yu" }; // (2)

// 배열을 초기화 할 때에는 (1) 방식을 사용하나, 
// 선언과 초기화를 따로 해야 하는 경우에는 (2) 방식 사용
```

## 4.3. 다차원 배열 & 가변 배열

| 선언방법 | 선언 예 |
| ------ | ------ |
| 타입[][] 변수이름; | int[][] score; |
| 타입 변수이름[][]; | int score[][]; |
| 타입[] 변수이름[]; | int[] score[]; |

두 번째 차원의 크기를 지정하지 않는 방식으로 **가변 배열**을 사용할 수 있다.
```java
int[][] score = new int[5][];
score[0] = new int[5];
score[1] = new int[4];
score[2] = new int[3];
score[3] = new int[2];
score[4] = new int[1];
```

## 4.4. 배열의 복사

배열 간의 내용을 복사하려면 `for`문을 사용하거나, System클래스의 `arraycopy()`를 사용하면 된다.

The syntax of `arraycopy`:
```java
System.arraycopy(arr1, 0, arr2, 0, arr1.length);
// arr1[0]에서 arr2[0]으로 arr1.length개의 데이터를 복사한다.
```

## 5. 객체지향 프로그래밍 I

## 5.1. 객체지향언어의 주요 특징

1. 코드의 재사용성이 높다.
	> 새로운 코드를 작성할 때 기존의 코드를 이용하여 쉽게 작성할 수 있다.
2. 코드의 관리가 용이하다.
	> 코드간의 관계를 이용해서 적은 노력으로 쉽게 코드를 변경할 수 있다.
3. 신뢰성이 높은 프로그래밍을 가능하게한다.
	> 제어자와 메서드를 이용해서 데이터를 보호하고 올바른 값을 유지하도록 하며,
	> 코드의 중복을 제거하여 코드의 불일치로 인한 오동작을 방지할 수 있다.


## 5.2. 클래스와 객체

> **클래스의 정의** - 객체를 정의해 놓은 것
> **클래스의 용도** - 객체를 생성하는데 사용

> **객체의 정의** - 실제로 존재하는 것. 사물 도는 개념
> **객체의 용도** - 객체가 가지고 있는 기능과 속성에 따라 다름

> **유형의 객체** - 책상, 의자, 자동차와 같은 사물
> **무형의 객체** - 수학공식, 프로그램 에러와 같은 논리나 개념


## 5.3. 객체와 인스턴스
클래스로부터 객체를 만드는 과정을 클래스의 ***인스턴스화(instantiate)***라고 하며,
어떤 클래스로부터 만들어진 객체를 그 클래스의***인스턴스(instance)***라고 한다.

## 5.4. 객채의 구성요소 - 속성과 기능

> **속성(property)** - **멤버변수(member variable)**, 특성(attribute), 필드(filed), 상태(status)
> **기능(function)** - **메서드(method)**, 행위(behavior), 함수(function)

The example of `class`:
```java
class Tv {
  // Tv의 속성(member variable)
  String color; // 색상
  boolean power; // 전원상태(on/off)
  int channel; // 채널
  
  // Tv의 기능(method)
  void power() { power != power; } // Tv를 켜거나 끄는 기능의 메서드
  void channelUp() { ++channel; } // Tv의 채널을 높이는 기능으 메서드
  void channelDown() { --channel; } // Tv의 채널을 낮추는 기능의 메서드
}

class TvTest {
  public void main(String args[]) {
    Tv t; // Tv인스턴스를 참조하기 위한 변수 t를 선언
    t = new Tv(); // Tv인스턴스를 생성
    t.channel = 7; // Tv인스턴스의 멤버변수를 channel의 값을 7로 셋팅
    t.channelDown(); // Tv인스턴스의 메서드 channelDown()을 호출, channel == 6
  }
}
```

> 인스턴스(instance)는 참조변수를 통해서만 다룰 수 있으며,
> 참조변수의 타입은 인스턴스의 타입과 일치해야 한다.

## 5.5. 변수와 메서드

```java
class Variables {
  int iv; // 인스턴스 변수(instance variable)
  static int cv; // 클래스 변수(class variable, static variable, shared variable)
	
  void method() {
  	int lv = 0; // 지역 변수(local variable)
  }
}
```

### 5.5.1. 변수

| 변수의 종류 | 선언위치 | 생성시기 |
| :------: | :------: | ------ |
| 클래스변수 <br> (class variable) | 클래스 영역 | 클래스가 메모리에 올라갈 때 |
| 인스턴스변수 <br> (instance variable) | 클래스 영역 | 인스턴스가 생성되었을 때 |
| 지역변수 <br> (local variable) | 클래스 영역 이외의 영역 <br> (메서드, 생성자, 초기화블럭 내부) | 변수 선언문이 수행되었을 때 |

> 인스턴스변수는 인스턴스가 생성될 때 마다 생성되므로 인스턴스마다 각기 다른 값을 유지할 수 있지만, 클래스 변수는 모든 인스턴스가 하나의 저장공간을 공유하므로, 항상 공통된 값을 갖는다.

### 5.5.2. 메서드
> 메서드는 어떤 작업을 수행하기 위한 명령문의 집합으로 선언부와 구현부로 나뉜다. 

- 하나의 메서드는 한 가지 기능만 수행하도록 작성하는 것이 좋다.
- 반복적으로 수행되어야 하는 여러 문장을 하나의 메서드로 정의해 놓으면 좋다.
- 관련된 여러 문장을 하나의 메서드로 만들어 놓는 것이 좋다.

The syntax:
```java
/*
리턴타입 메서드명(타입 변수명, 타입 변수명, ...) {
  // 메서드 호출시 수행될 코드
}
*/

int add(int a, int b) {
  int result = a + b;
  
  return result; // 호출한 메서드의 결과를 반환
}

void power() { // 반환값이 없는 경우 리턴타입 대신 void를 사용
  power = !power;
}
```

### 5.5.3. `return` 문

메서드가 정상적으로 종료되는 경우: 
> - 메서드의 블럭`{}`내의 마지막 문장까지 수행되었을 때
> - 메서드의 블럭`{}`내에 있는 문장을 수행 중 `return`문을 만났을 때

- 반환값이 있는 경우, 반환값은 메서드의 선엄주에 정의된 반환타입과 일치하거나, 
반환타입으로 자동형변환이 가능한 것이어야 한다.
- 메서드 내에서 `return`문을 여러 번 쓰는 것보다 가능하면 변수를 사용해서 리턴값을
저장했다가 마지막에 한 번만 사용하는 것이 좋다.


### 5.5.4. JVM의 메모리구조

1. 메서드 영역(Method area)
	> 프로그램 실행 중 어떤 클래스가 사용되면, JVM은 해당 클래스의 클래스파일(*.class)을 읽어서 분석하여 클래스에 대한 정보(클레스 데이터)를 이곳에 저장한다, 이 때, 그 클래스의 클래스변수(class variable)도 이 영역에 함께 생성된다.
2. 힙(Heap)
	> 인스턴스가 생성되는 공간. 프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성된다. 즉, 인스턴스변수(instance variable)들이 생성되는 공간이다.
3. 호출스택(Call stack 또는 Execution stack)
	> 호출스택은 메서드의 작업에 필요한 메모리 공간을 제공한다. 메서드가 호출되면, 호출스택에 호출된 메서드를 위한 메모리가 할당되며, 이 메모리는 메서드가 작업을 수행되는 동안 지역변수(매개변수 포함)들과 연산의 중간결과 등을 저장하는데 사용된다. 그리고 메서드가 작업을 마치면 할당되었던 메모리공간은 반환되어 비워진다.

### 5.5.5. 기본형 매개변수와 참조형 매개변수

> **기본형 매개변수** - 변수의 앖을 읽기만 할 수 있다.(read only)
> **참조형 매개변수** - 변수의 값을 읽고 변경할 수 있다. (rea & write)

### 5.5.6. 클래스메서드(static method)와 인스턴스메서드(instance method)

> **인스턴스메서드** - 인스턴스변수와 관련된 작업을 하는, 즉 메서드의 작업을 수행하는데 인스턴스변수를 필요로하는 메서드이다.
> **클래스메서드** - 인스턴스와 관계없는(인스턴스변수나 인스턴스메서드를 사용하지 않는) 메서드를 클래스메서드(static method)라고 하며, 변수 선언부의 앞에 `static`을 붙인다.

- 클래스의 멤버변수 중 모든 인스턴스에 공통된 값을 유지해야하는 것이 있는지 살펴보고 있으면, `static`을 붙여준다.
- 메서드 내에서 인스턴스변수를 사용하지 않는다면, `static`을 붙여 클래스메서드로 사용한다.
	> 메서드 호출시간이 짧아지기 때문에 효율이 높아진다.

## 5.6. 메서드 오버로딩(Method overloading)
> 한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것을
> **메서드 오버로딩** 또는 간단히 **오버로딩**이라 한다. (같은 기능 수행)

1. 메서드 이름이 같아야 한다.
2. 매개변수의 개수 또는 타입이 달라야 한다.
3. 매개변수는 같고 리턴타입이 다른 경우에는 오버로딩이 성립되지 않는다.

## 5.7. 생성자(Constructor)

> 생성자는 인스턴스가 생성될 때 호출되는 '인스턴스 초기화 메서드'이다.
> 따라서 인스턴스 변수의 초기화 작업에 주로 사용되며, 인스턴스 생성 시에 실행되어야
> 할 작업을 위해서도 사용된다.

생성자의 조건:
1. 생성자의 이름은 클래스의 이름과 같아야 한다.
2. 생성자는 리턴 값이 없다.
3. 생성자도 오버로딩(Overloading)이 가능하므로, 하나의 클래스에 여러 개의 생성자가 존재할 수 있다.

### 5.7.1. 생성자에서 다른 생성자 호출하기 - `this()`, `this`

같은 클래스의 멤버들 간에 서로 호출할 수 있는 것처럼 생성자 간에도 서로 호출이 가능하다.
단, 다음의 두 조건을 만족시켜야 한다.

- 생성자의 이름으로 클래스이름 대신 `this`를 사용한다.
- 한 생성자에서 다른 생성자를 호출할 때 반드시 첫 줄에서만 호출이 가능하다.

> `this` - 인스턴스 자신을 가리키는 참조변수, 인스턴스의 주소가 저장되어 있다. 모든 인스턴스 메서드에 지역변수로 숨겨진 채로 존재한다. 
> `this()`, `this(매개변수)` - 생성자, 같은 클래스의 다른 생성자를 호출할 때 사용된다.

### 5.7.2. 생성자를 이용한 인스턴스의 복사

```java
Car(Car c) {
  color = c.color;
  getType = c.getType;
  door = c.door;
}
```

## 5.8. 변수의 초기화

멤버변수(클래스변수와 인스턴스변수)는 초기화를 하지 않아도 자동적으로 변수의 자료형에 맞는 기본값으로 초기화가 이루어지므로 초기화하지 않고 사용해도 되지만, ++**지역변수**는 사용하기 전에 반드시 초기화를 해야한다.++

**멤버변수의 초기화 방법**
1. 명시적 초기화(Explicit initialization)
2. 생성자(Constructor)
3. 초기화 블럭(Initialization block), 인스턴스 초기화 블럭과 클래스 초기화 블럭으로 나뉜다.
	> 초기화 작업이 복잡하여 명시적 초기화만으로는 부족한 경우 초기화 블럭을 사용한다.
	> - 인스턴스 초기화 불럭이 생성자보다 먼저 수행된다.

  ```java
  class InitBlock {
    static { /* 클래스 초기화 블럭 */ }
    
    { /* 인스턴스 초기화 블럭 */ }
    
    // ...
  }
  ```

## 6. 객체지향 프로그래밍 II

## 6.1. 상속(Inheritance)

`To be continue :) `